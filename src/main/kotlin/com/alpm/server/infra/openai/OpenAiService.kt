package com.alpm.server.infra.openai

import com.alpm.server.global.common.model.Language
import com.alpm.server.infra.openai.dto.ChatMessageDto
import com.alpm.server.infra.openai.dto.ChatRequestDto
import com.alpm.server.infra.openai.dto.ChatResponseDto
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpEntity
import org.springframework.http.HttpHeaders
import org.springframework.http.HttpMethod
import org.springframework.stereotype.Service
import org.springframework.web.client.RestTemplate

@Service
class OpenAiService (

    @Value("\${openai.token}")
    private val token: String,

    @Value("\${openai.url}")
    private val url: String,

    private val restTemplate: RestTemplate

) {

    private val cAnnotatePrompt = arrayListOf(
        "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll N, M;\nll arr[100005];\nvector<ll> SegTree;\nll Query(ll n, ll l, ll r, ll st, ll ed){\n    if (l>ed || r<st)\n        return 0;\n    if (l>=st && r<=ed)\n        return SegTree[n];\n    ll mid=(l+r)/2;\n    return Query(n*2,l,mid,st,ed)+Query(n*2+1,mid+1,r,st,ed);\n}\nll Update(ll n, ll l, ll r, ll pos, ll x){\n    if (l>pos || r<pos)\n        return SegTree[n];\n    if (l==r)\n        return SegTree[n]=x;\n    ll mid=(l+r)/2;\n    return SegTree[n]=Update(n*2,l,mid,pos,x)+Update(n*2+1,mid+1,r,pos,x);\n}\nll Init(ll n, ll l, ll r){\n    if (l==r)\n        return SegTree[n]=arr[l];\n    ll mid=(l+r)/2;\n    return SegTree[n]=Init(n*2,l,mid)+Init(n*2+1,mid+1,r);\n}\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> N >> M;\n    for (int i=1;i<=N;i++)\n        cin >> arr[i];\n    SegTree.resize(4*N);\n    Init(1,1,N);\n    for (int i=0;i<M;i++){\n        ll x, a, b;\n        cin >> x >> a >> b;\n        if (x)\n            cout << Query(1,1,N,a,b) << \"\\n\";\n        else\n            Update(1,1,N,a,b);\n    }\n    return 0;\n}",
        "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nll N, M;\nll arr[100005];\nvector<ll> SegTree;\n\nll Query(ll n, ll l, ll r, ll st, ll ed) {\n    if (l > ed || r < st) // 탐색 범위를 벗어나는 경우\n        return 0;\n    if (l >= st && r <= ed) // 목표 범위에 속하는 경우\n        return SegTree[n];\n    ll mid = (l + r) / 2; // 중심값 선언\n    return Query(n * 2, l, mid, st, ed) + Query(n * 2 + 1, mid + 1, r, st, ed); // 왼쪽 구간과 오른쪽 구간을 탐색\n} \n\nll Update(ll n, ll l, ll r, ll pos, ll x) {\n    if (l > pos || r < pos) // 탐색범위를 벗어나면\n        return SegTree[n]; // 해당 세그먼트 트리의 값을 반환\n    if (l == r) { // leaf node에 도달하면\n        SegTree[n] = x;\n        return SegTree[n]; // 새로 입력받은 값을 반환\n    }\n    ll mid = (l + r) / 2; // 중심값 선언\n    SegTree[n] = Update(n * 2, l, mid, pos, x) + Update(n * 2 + 1, mid + 1, r, pos, x); // 왼쪽 구간과 오른쪽 구간을 탐색\n    return SegTree[n];\n}\n\nll Init(ll n, ll l, ll r) {\n    if (l == r) { // leaf node에 도달하면\n        SegTree[n] = arr[l]; // arr[l] 값이 상위노드로 넘어감\n        return SegTree[n];\n    }\n    ll mid = (l + r) / 2; // 중심값 선언\n    SegTree[n] = Init(n * 2, l, mid) + Init(n * 2 + 1, mid + 1, r); // 왼쪽 구간과 오른쪽 구간으로 분할\n    return SegTree[n];\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> N >> M;\n    for (int i = 1; i <= N; i++)\n        cin >> arr[i]; // 원소 입력 받음\n\n    SegTree.resize(4 * N); // 세그먼트 트리 크기가 4*N 인 벡터 생성\n    Init(1, 1, N); // 세그먼트 트리 초기화\n\n    for (int i = 0; i < M; i++) {\n        ll x, a, b;\n        cin >> x >> a >> b;\n        if (x) // x가 1이면\n            cout << Query(1, 1, N, a, b) << \"\\n\"; // a번째부터 b번째까지의 합 출력\n        else // x가 0이면\n            Update(1, 1, N, a, b); // a번째 원소를 b로 변경\n    }\n\n    return 0;\n}",
        "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll N;\nll arr[1005];\nvoid SelectionSort(){\n    for (int i=0;i<N;i++){\n        ll mn=i;\n        for (int j=i+1;j<N;j++){\n            if (arr[mn]>arr[j])\n                mn=j;\n        }\n        if (i!=mn){\n            ll tmp=arr[i];\n            arr[i]=arr[mn];\n            arr[mn]=tmp;\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> N;\n    for (int i=0;i<N;i++)\n        cin >> arr[i];\n    SelectionSort();\n    for (int i=0;i<N;i++)\n        cout << arr[i] << \" \";\n    return 0;\n}",
        "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nll N; // 배열의 크기를 나타내는 변수\nll arr[1005]; // 정렬할 배열\n\nvoid SelectionSort() { // 선택 정렬 함수\n    for (int i = 0; i < N; i++) { // 배열의 모든 요소를 확인하며 가장 작은 값을 찾아서 앞으로 이동시킴\n        ll mn = i; // 가장 작은 값을 가리키는 인덱스\n        \n        for (int j = i + 1; j < N; j++) { // 현재 인덱스 이후의 요소 중에서 가장 작은 값을 찾음\n            if (arr[mn] > arr[j])\n                mn = j;\n        }\n        \n        if (i != mn) { // 현재 인덱스와 가장 작은 값의 인덱스가 다를 경우 위치를 변경함\n            ll tmp = arr[i];\n            arr[i] = arr[mn];\n            arr[mn] = tmp;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> N; // 배열의 크기를 입력 받음\n    for (int i = 0; i < N; i++) // 배열의 요소를 입력 받음\n        cin >> arr[i];\n\n    \n    SelectionSort(); // 선택 정렬 수행\n\n    for (int i = 0; i < N; i++) // 정렬된 배열을 출력\n        cout << arr[i] << \" \";\n\n    return 0;\n}",
        "위 예시처럼 주어진 코드를 예쁘게 정렬하고 핵심 내용에 대해 반드시 한글로 주석을 작성해 줘. 단, 'Init(1, 1, N); // 세그먼트 트리 초기화'와 같이 주석은 반드시 설명하고자 하는 부분의 오른쪽에 위치해야 해. 부가적인 설명 없이 코드와 주석만 작성해 줘. ```로 감쌀 필요도 없어. "
    )

    private val pythonAnnotatePrompt = arrayListOf(
        "import sys\nsys.setrecursionlimit(10**6)\n\ndef query(n,l,r,st,ed):\n    if l>ed or r<st:\n        return 0\n    if l>=st and r<=ed:\n        return seg_tree[n]\n    mid=(l+r)//2\n    return query(n*2,l,mid,st,ed)+query(n*2+1,mid+1,r,st,ed)\n\ndef update(n,l,r,pos,x):\n    if l>pos or r<pos:\n        return seg_tree[n]\n    if l==r:\n        seg_tree[n]=x\n        return x\n    mid=(l+r)//2\n    seg_tree[n]=update(n*2,l,mid,pos,x)+update(n*2+1,mid+1,r,pos,x)\n    return seg_tree[n]\n\ndef init(n,l,r):\n    if l==r:\n        seg_tree[n]=arr[l]\n        return arr[l]\n    mid=(l+r)//2\n    seg_tree[n]=init(n*2,l,mid)+init(n*2+1,mid+1,r)\n    return seg_tree[n]\n\nN,M=map(int,input().split())\narr=[0]+list(map(int, input().split()))\nseg_tree=[0]*(4*N)\ninit(1,1,N)\nfor _ in range(M):\n    x,a,b=map(int,input().split())\n    if x:\n        print(query(1,1,N,a,b))\n    else:\n        update(1,1,N,a,b)",
        "import sys\nsys.setrecursionlimit(10**6)\n\ndef query(n, l, r, st, ed):\n    if l > ed or r < st: # 범위 밖인 경우 0 반환\n        return 0\n    if l >= st and r <= ed: # 범위 내에 완전히 속한 경우 현재 노드의 값 반환\n        return seg_tree[n]\n    mid = (l + r) // 2 # 중간 지점 계산\n    return query(n * 2, l, mid, st, ed) + query(n * 2 + 1, mid + 1, r, st, ed)\n\ndef update(n, l, r, pos, x):\n    if l > pos or r < pos: # 업데이트 위치가 범위 밖인 경우 현재 노드 값 반환\n        return seg_tree[n]\n    if l == r: # 리프 노드인 경우 값 업데이트\n        seg_tree[n] = x\n        return x\n    mid = (l + r) // 2 # 중간 지점 계산\n    seg_tree[n] = update(n * 2, l, mid, pos, x) + update(n * 2 + 1, mid + 1, r, pos, x)\n    return seg_tree[n]\n\ndef init(n, l, r):\n    if l == r: # 리프 노드인 경우 배열 값으로 초기화\n        seg_tree[n] = arr[l]\n        return arr[l]\n    mid = (l + r) // 2 # 중간 지점 계산\n    seg_tree[n] = init(n * 2, l, mid) + init(n * 2 + 1, mid + 1, r)\n    return seg_tree[n]\n\nN, M = map(int, input().split()) # 배열 크기 N과 쿼리 수 M 입력\narr = [0] + list(map(int, input().split())) # 배열 입력 (1-indexed)\nseg_tree = [0] * (4 * N) # 세그먼트 트리 초기화\ninit(1, 1, N) # 세그먼트 트리 초기화\n\nfor _ in range(M):\n    x, a, b = map(int, input().split())\n    if x: # 쿼리 연산\n        print(query(1, 1, N, a, b))\n    else: # 업데이트 연산\n        update(1, 1, N, a, b)",
        "def SelectionSort(arr):\n    for i in range(len(arr)):\n        mn=i\n        for j in range(i+1,len(arr)):\n            if arr[mn] > arr[j]:\n                mn=j\n        if i!=mn:\n            arr[i],arr[mn]=arr[mn],arr[i]\n\nN=int(input())\narr=list(map(int,input().split()))\nSelectionSort(arr)\nprint(*arr)",
        "def SelectionSort(arr):\n    for i in range(len(arr)): # 배열의 각 요소에 대해\n        mn = i # 현재 위치를 최소값 인덱스로 초기화\n        for j in range(i + 1, len(arr)): # 현재 위치 이후의 요소들을 순회\n            if arr[mn] > arr[j]: # 현재 최소값보다 작은 값을 찾으면\n                mn = j # 최소값 인덱스를 업데이트\n        if i != mn: # 최소값 인덱스가 현재 위치와 다르면\n            arr[i], arr[mn] = arr[mn], arr[i] # 두 값을 교환\n\nN = int(input()) # 배열 크기 N 입력\narr = list(map(int, input().split())) # 배열 요소 입력\nSelectionSort(arr) # 선택 정렬 함수 호출\nprint(*arr) # 정렬된 배열 출력\n",
        "위 예시처럼 주어진 코드를 예쁘게 정렬하고 핵심 내용에 대해 반드시 한글로 주석을 작성해 줘. 단, 'init(1, 1, N) # 세그먼트 트리 초기화'와 같이 주석은 반드시 설명하고자 하는 부분의 오른쪽에 위치해야 해. 코드와 주석이 아닌 부가적인 설명은 생략해 줘. ```로 감쌀 필요도 없어. "
    )

    private val javaAnnotatePrompt = arrayListOf(
        "import java.util.*;\n\npublic class SegmentTree{\n    static int N, M;\n    static int[] arr=new int[100005];\n    static ArrayList<Integer> SegTree=new ArrayList<>();\n\n    public static int Query(int n, int l, int r, int st, int ed){\n        if (l>ed || r<st)\n            return 0;\n        if (l>=st && r<=ed)\n            return SegTree.get(n);\n        int mid=(l+r)/2;\n        return Query(n*2,l,mid,st,ed)+Query(n*2+1,mid+1,r,st,ed);\n    }\n\n    public static int Update(int n, int l, int r, int pos, int x){\n        if (l>pos || r<pos)\n            return SegTree.get(n);\n        if (l==r){\n            SegTree.set(n,x);\n            return SegTree.get(n);\n        }\n        int mid=(l+r)/2;\n        SegTree.set(n,Update(n*2,l,mid,pos,x)+Update(n*2+1,mid+1,r,pos,x));\n        return SegTree.get(n);\n    }\n\n    public static int Init(int n, int l, int r){\n        if (l==r){\n            SegTree.set(n,arr[l]);\n            return SegTree.get(n);\n        }\n        int mid=(l+r)/2;\n        SegTree.set(n,Init(n*2,l,mid)+Init(n*2+1,mid+1,r));\n        return SegTree.get(n);\n    }\n\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        N=sc.nextInt();\n        M=sc.nextInt();\n        for (int i=1;i<=N;i++)\n            arr[i]=sc.nextInt();\n        for (int i=0;i<4*N;i++)\n            SegTree.add(0);\n        Init(1,1,N);\n        for (int i=0;i<M;i++){\n            int x=sc.nextInt();\n            int a=sc.nextInt();\n            int b=sc.nextInt();\n            if (x!=0)\n                System.out.println(Query(1,1,N,a,b));\n            else\n                Update(1,1,N,a,b);\n        }\n        sc.close();\n    }\n}",
        "import java.util.*;\n\npublic class SegmentTree {\n\n    static int N, M;  // 배열의 크기 N과 쿼리의 수 M\n    static int[] arr = new int[100005];  // 입력 배열\n    static ArrayList<Integer> SegTree = new ArrayList<>();  // 세그먼트 트리 배열\n\n    public static int Query(int n, int l, int r, int st, int ed) {  // 구간 합을 구하는 쿼리 함수\n        if (l > ed || r < st)  // 탐색 범위를 벗어나는 경우\n        return 0;\n    if (l >= st && r <= ed) // 목표 범위에 속하는 경우\n        return SegTree[n];\n        int mid = (l + r) / 2;  // 중심값 선언\n    return Query(n * 2, l, mid, st, ed) + Query(n * 2 + 1, mid + 1, r, st, ed); // 왼쪽 구간과 오른쪽 구간을 탐색\n    }\n\n    public static int Update(int n, int l, int r, int pos, int x) { // 세그먼트 트리 업데이트 함수\n        if (l > pos || r < pos) // 탐색범위를 벗어나면\n        return SegTree[n]; // 해당 세그먼트 트리의 값을 반환\n    if (l == r) { // leaf node에 도달하면\n        SegTree[n] = x;\n        return SegTree[n]; // 새로 입력받은 값을 반환\n    }\n        int mid = (l + r) / 2; // 중심값 선언\n        SegTree.set(n, Update(n * 2, l, mid, pos, x) + Update(n * 2 + 1, mid + 1, r, pos, x));  // 왼쪽 구간과 오른쪽 구간을 탐색\n        return SegTree.get(n);\n    }\n\n    public static int Init(int n, int l, int r) { // 세그먼트 트리 초기화 함수\n        if (l == r) {  // 리프 노드인 경우\n            SegTree.set(n, arr[l]);  // 입력 배열의 값으로 초기화\n            return SegTree.get(n);  \n        }\n        int mid = (l + r) / 2;  // 중간 인덱스 계산\n        SegTree.set(n, Init(n * 2, l, mid) + Init(n * 2 + 1, mid + 1, r));  // 좌우 자식을 재귀적으로 호출하여 초기화\n        return SegTree.get(n);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);  // 입력을 받기 위한 스캐너 객체 생성\n        N = sc.nextInt();  // 배열의 크기 입력\n        M = sc.nextInt();  // 쿼리의 수 입력\n        for (int i = 1; i <= N; i++) arr[i] = sc.nextInt();  // 배열의 요소 입력\n        for (int i = 0; i < 4 * N; i++) SegTree.add(0);  // 세그먼트 트리 크기가 4*N 인 벡터 생성\n        Init(1, 1, N);  // 세그먼트 트리 초기화\n        for (int i = 0; i < M; i++) {\n            int x = sc.nextInt();  // 쿼리 유형 입력 (0: 업데이트, 1: 구간 합)\n            int a = sc.nextInt();  // 첫 번째 인자 입력\n            int b = sc.nextInt();  // 두 번째 인자 입력\n            if (x != 0) System.out.println(Query(1, 1, N, a, b));  // 구간 합 쿼리 수행 후 출력\n            else Update(1, 1, N, a, b);  // 업데이트 쿼리 수행\n        }\n        sc.close();  // 스캐너 닫기\n    }\n}",
        "import java.util.*;\n\npublic class SelectionSort{\n    static int N;\n    static int[] arr=new int[1005];\n\n    public static void SelectionSort(){\n        for (int i=0;i<N;i++){\n            int mn=i;\n            for (int j=i+1;j<N;j++){\n                if (arr[mn]>arr[j])\n                    mn=j;\n            }\n            if (i!=mn){\n                int tmp=arr[i];\n                arr[i]=arr[mn];\n                arr[mn]=tmp;\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        N=sc.nextInt();\n        for (int i=0;i<N;i++)\n            arr[i]=sc.nextInt();\n        SelectionSort();\n        for (int i=0;i<N;i++)\n            System.out.print(arr[i]+\" \");\n        sc.close();\n    }\n}",
        "import java.util.*;\n\npublic class SelectionSort {\n\n    static int N;  // 배열의 크기\n    static int[] arr = new int[1005];  // 정렬할 배열\n\n    public static void SelectionSort() {\n        for (int i = 0; i < \$N\$; i++) { // 배열의 모든 요소를 확인하며 가장 작은 값을 찾아서 앞으로 이동시킴\n            int mn = i;  // 가장 작은 값을 가리키는 인덱스\n            for (int j = i + 1; j < \$N\$; j++) {  // 현재 위치 이후의 요소들을 순회\n                if (arr[\$mn\$] > arr[\$j\$])\n                    mn = j;  // 현재 최소값보다 작은 값을 찾으면 최소값 인덱스를 업데이트\n            }\n            if (i != \$mn\$) {  // 최소값 인덱스가 현재 위치와 다르면\n                int tmp = arr[\$i\$];  // 두 값을 교환\n                arr[\$i\$] = arr[\$mn\$];\n                arr[\$mn\$] = tmp;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);  // 입력을 받기 위한 스캐너 객체 생성\n        N = sc.nextInt();  // 배열의 크기 입력\n        for (int i = 0; i < \$N\$; i++) arr[i] = sc.nextInt();  // 배열의 요소 입력\n        SelectionSort();  // 선택 정렬 수행\n        for (int i = 0; i < \$N\$; i++) System.out.print(arr[\$i\$] + \" \");  // 정렬된 배열 출력\n        sc.close();  // 스캐너 닫기\n    }\n}",
        "위 예시처럼 주어진 코드를 예쁘게 정렬하고 핵심 내용에 대해 반드시 한글로 주석을 작성해 줘. 단, 'Init(1, 1, N);  // 세그먼트 트리 초기화'와 같이 주석은 반드시 설명하고자 하는 부분의 오른쪽에 위치해야 해. 코드와 주석이 아닌 부가적인 설명은 생략해 줘. ```로 감쌀 필요도 없어. "
    )

    private val cBlankPrompt = arrayListOf(
        "You read the code, identify the important parts, and drill through the blanks so that the user can match the contents that will be in the blanks.",
        "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1e9+7)\nusing namespace std;\n\nstruct Edge { // 간선을 나타내는 구조체\n    ll st, ed, dst; // 시작점, 끝점, 가중치\n};\n\nll N, M, K;\nll visited[1005]; // 방문 여부를 나타내는 배열\nvector<Edge> arr; // 간선 정보를 담는 배열\n\nvoid BellmanFord() { // 벨만-포드 알고리즘 수행 함수\n    for (int i = 1; i <= N; i++) { // 모든 노드에 대해\n        if (visited[i] == INF) { // 무한대 값으로 초기화된 경우\n            visited[i] = 0; // 시작점으로부터의 최단 거리 정점을 0으로 설정\n            for (int j = 0; j < N; j++) { // 최대 N-1번 반복\n                for (int k = 0; k < arr.size(); k++) { // 모든 간선에 대해\n                    if (visited[arr[k].st] == INF) // 시작점이 무한대 값인 경우\n                        continue;\n                    visited[arr[k].ed] = min(visited[arr[k].ed], visited[arr[k].st] + arr[k].dst); // 도착점에 대한 최단 거리 갱신\n                }\n            }\n            for (int j = 0; j < arr.size(); j++) { // 음수 사이클이 있는지 확인\n                if (visited[arr[j].st] == INF) // 시작점이 무한대 값인 경우\n                    continue;\n                if (visited[arr[j].ed] > visited[arr[j].st] + arr[j].dst) { // 음수 사이클이 있을 경우\n                    cout << \"Yes\\n\"; // 출력하고\n                    return; // 종료\n                }\n            }\n        }\n    }\n    cout << \"No\\n\"; // 음수 사이클이 없는 경우\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> N >> M; // 노드의 개수와 간선의 개수 입력\n    fill(&visited[0], &visited[N+1], INF); // visited 배열을 모두 무한대 값으로 초기화\n\n    for (int i = 0; i < M; i++) { // 간선 정보 입력\n        ll a, b, c;\n        cin >> a >> b >> c;\n        arr.push_back({a, b, c}); // 간선 정보 저장\n    }\n\n    BellmanFord(); // 벨만-포드 알고리즘 수행\n\n    return 0;\n}",
        "#include <bits/stdc++.h>\n#define ll long long\n#define INF (1e9+7)\nusing namespace std;\n\nstruct Edge { // 간선을 나타내는 구조체\n    ll st, ed, dst; // 시작점, 끝점, 가중치\n};\n\nll N, M, K;\nll visited[1005]; // 방문 여부를 나타내는 배열\nvector<Edge> arr; // 간선 정보를 담는 배열\n\nvoid BellmanFord() { // 벨만-포드 알고리즘 수행 함수\n    for (int i = 1; i <= N; i++) { // 모든 노드에 대해\n        if (\$visited[i]\$ == INF) { // 무한대 값으로 초기화된 경우\n            visited[i] = 0; // 시작점으로부터의 최단 거리 정점을 0으로 설정\n            for (int j = 0; j < N; j++) { // 최대 N-1번 반복\n                for (int k = 0; k < \$arr.size()\$; k++) { // 모든 간선에 대해\n                    if (\$visited[arr[k].st]\$ == INF) // 시작점이 무한대 값인 경우\n                        \$continue\$;\n                    visited[arr[k].ed] = min(\$visited[arr[k].ed]\$, \$visited[arr[k].st] + arr[k].dst\$); // 도착점에 대한 최단 거리 갱신\n                }\n            }\n            for (int j = 0; j < \$arr.size()\$; j++) { // 음수 사이클이 있는지 확인\n                if (\$visited[arr[j].st]\$ == INF) // 시작점이 무한대 값인 경우\n                    \$continue\$;\n                if (\$visited[arr[j].ed]\$ > \$visited[arr[j].st] + arr[j].dst\$) { // 음수 사이클이 있을 경우\n                    cout << \"Yes\\n\"; // 출력하고\n                    return; // 종료\n                }\n            }\n        }\n    }\n    cout << \"No\\n\"; // 음수 사이클이 없는 경우\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> N >> M; // 노드의 개수와 간선의 개수 입력\n    fill(&visited[0], &visited[N+1], INF); // visited 배열을 모두 무한대 값으로 초기화\n\n    for (int i = 0; i < M; i++) { // 간선 정보 입력\n        ll a, b, c;\n        cin >> a >> b >> c;\n        arr.push_back({a, b, c}); // 간선 정보 저장\n    }\n\n    BellmanFord(); // 벨만-포드 알고리즘 수행\n\n    return 0;\n}",
        "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstruct Edge { // 간선을 표현하는 구조체\n    ll x, y, dst; // 출발점, 도착점, 가중치\n};\n\nbool operator<(Edge x, Edge y) { // 우선순위 큐를 위한 연산자 오버로딩\n    return x.dst > y.dst; // 가중치가 작은 순서대로 우선순위 큐에 저장\n}\n\nll N, M; // 노드의 개수, 간선의 개수\nll arr[1005]; // 각 노드의 루트 노드를 저장하는 배열\npriority_queue<Edge> pq; // 우선순위 큐\n\nll Find(ll x) { // 루트 노드 찾기\n    if (x == arr[x]) \n        return x;\n    return arr[x] = Find(arr[x]); // 경로 압축: 부모 노드를 바로 루트 노드로 변경\n}\n\nvoid Union(ll x, ll y) { // 두 노드를 연결하는 함수\n    arr[Find(x)] = Find(y); // 두 노드를 연결하기 위해 두 노드의 루트 노드를 연결\n}\n\nll Kruskal() { // 크루스칼 알고리즘 수행\n    ll ret = 0; // 총 가중치의 합\n    while (!pq.empty()) {\n        ll x = pq.top().x, y = pq.top().y, curr = pq.top().dst; // 현재 간선의 정보\n        pq.pop();\n        if (Find(x) == Find(y)) // 사이클이 생기는지 체크\n            continue;\n        Union(x, y); // 두 노드를 연결\n        ret += curr; // 가중치 추가\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    \n    cin >> N >> M; // 노드의 개수와 간선의 개수 입력\n    iota(&arr[0], &arr[1004], 0); // 배열 초기화\n    for (int i = 0; i < M; i++) {\n        ll a, b, c;\n        cin >> a >> b >> c; // 출발점, 도착점, 가중치 입력\n        pq.push({a, b, c}); // 우선순위 큐에 저장\n    }\n\n    cout << Kruskal(); // 크루스칼 알고리즘 수행 후 결과 출력\n\n    return 0;\n}",
        "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstruct Edge { // 간선을 표현하는 구조체\n    ll x, y, dst; // 출발점, 도착점, 가중치\n};\n\nbool operator<(Edge x, Edge y) { // 우선순위 큐를 위한 연산자 오버로딩\n    return x.dst > y.dst; // 가중치가 작은 순서대로 우선순위 큐에 저장\n}\n\nll N, M; // 노드의 개수, 간선의 개수\nll arr[1005]; // 각 노드의 루트 노드를 저장하는 배열\npriority_queue<Edge> pq; // 우선순위 큐\n\nll Find(ll x) { // 루트 노드 찾기\n    if (\$x\$ == arr[x]) \n        return \$x\$;\n    return arr[x] = \$Find(arr[x])\$; // 경로 압축: 부모 노드를 바로 루트 노드로 변경\n}\n\nvoid Union(ll x, ll y) { // 두 노드를 연결하는 함수\n    arr[Find(x)] = \$Find(y)\$; // 두 노드를 연결하기 위해 두 노드의 루트 노드를 연결\n}\n\nll Kruskal() { // 크루스칼 알고리즘 수행\n    ll ret = 0; // 총 가중치의 합\n    while (\$!pq.empty()\$) {\n        ll x = pq.top().x, y = pq.top().y, curr = pq.top().dst; // 현재 간선의 정보\n        \$pq.pop();\$\n        if (\$Find(x)\$ == Find(y)) // 사이클이 생기는지 체크\n            \$continue\$;\n        Union(x, y); // 두 노드를 연결\n        \$ret\$ += \$curr\$; // 가중치 추가\n    }\n    return \$ret\$;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    \n    cin >> N >> M; // 노드의 개수와 간선의 개수 입력\n    iota(&arr[0], &arr[1004], 0); // 배열 초기화\n    for (int i = 0; i < M; i++) {\n        ll a, b, c;\n        cin >> a >> b >> c; // 출발점, 도착점, 가중치 입력\n        pq.push({a, b, c}); // 우선순위 큐에 저장\n    }\n\n    cout << Kruskal(); // 크루스칼 알고리즘 수행 후 결과 출력\n\n    return 0;\n}",
        "Just like the input and output above, understand the code below, wrap it in \$, and print it out. The part wrapped in \$ will be blank and will be presented as a question. However, the following conditions must be observed.\n\n1. The structure variable, the generator part, should never be wrapped in \$.\n2. You can't just wrap the constant in \$. \n3. The commentary should never be changed.\n4. Any part that declares a variable, such as 'll a = 0;' or 'Queue<ll> q;', should never be wrapped in \$. This is the same in the statement for.\n5. The part that defines a function, such as 'll Func(ll a) {' should never be wrapped in \$.\n6. For comparative operators such as '>, '<', '==', and '!=', only the latter part of the operator should be wrapped in \$. For example, for 'a == b', only 'a == \$b\$.\n7. Parts that are entered or printed, such as 'cin>a>b' and 'printf()', should not be wrapped in \$.\n8. When calling a function, if there are 0 to 2 factors of the  function, like 'a.top()', 'a.\$top()\$' wraps the entire function in \$.\n9. When calling a function, if there are three or more factors of the function, such as 'f(a, b, c), wrap the name and factor of the function with \$, as in '\$f\$(a\$, \$b\$ and \$c\$).\n10. If break, continue, and return are also key parts, please wrap them in \$.\n\nWrap as much as you can in \$ to satisfy all of the above conditions and explain one by one why you wrapped those parts in \$.\nWrap the entire code in ``` without the language of that code. "
    )

    private val pythonBlankPrompt = arrayListOf(
        "You read the code, identify the important parts, and drill through the blanks so that the user can match the contents that will be in the blanks.",
        "INF = 10**9 + 7\n\nclass Edge:\n    def __init__(self, st, ed, dst):\n        self.st = st\n        self.ed = ed\n        self.dst = dst\n\ndef BellmanFord():\n    for i in range(1, N + 1): # 모든 노드에 대해\n        if visited[i] == INF: # 방문하지 않은 노드면\n            visited[i] = 0 # 출발점으로부터의 거리 0으로 초기화\n            for _ in range(N): # 최대 N-1번 반복\n                for j in arr: # 간선 정보에 대해\n                    if visited[j.st] == INF: # 출발지가 아직 방문되지 않았다면 무시\n                        continue\n                    visited[j.ed] = min(visited[j.ed], visited[j.st] + j.dst) # 간선을 통해 거리 업데이트\n            for j in arr: # 음수 사이클 존재 여부 확인을 위해 한 번 더 반복\n                if visited[j.st] == INF: # 출발지가 아직 방문되지 않았다면 무시\n                    continue\n                if visited[j.ed] > visited[j.st] + j.dst: # 음수 사이클이 존재하면\n                    print(\"Yes\") # \"Yes\" 출력하고 함수 종료\n                    return\n    print(\"No\") # 음수 사이클이 존재하지 않으면 \"No\" 출력\n\nN, M = map(int, input().split()) # 노드 수 N과 간선 수 M 입력\nvisited = [INF] * (N + 1) # 방문 여부와 최단거리를 저장할 배열 초기화\narr = [] # 간선 정보 저장할 리스트\nfor _ in range(M): # 간선 정보 입력\n    a, b, c = map(int, input().split())\n    arr.append(Edge(a, b, c)) # Edge 클래스로 간선 생성하여 배열에 추가\nBellmanFord() # 벨만-포드 알고리즘 수행",
        "INF = 10**9 + 7\n\nclass Edge:\n    def __init__(self, st, ed, dst):\n        self.st = st\n        self.ed = ed\n        self.dst = dst\n\ndef BellmanFord():\n    for i in range(1, N + 1): # 모든 노드에 대해\n        if \$visited[i]\$ == INF: # 방문하지 않은 노드면\n            visited[i] = 0 # 출발점으로부터의 거리 0으로 초기화\n            for _ in range(N): # 최대 N-1번 반복\n                for j in \$arr\$: # 간선 정보에 대해\n                    if \$visited[j.st]\$ == INF: # 출발지가 아직 방문되지 않았다면 무시\n                        \$continue\$\n                    visited[j.ed] = min(\$visited[j.ed]\$, \$visited[j.st] + j.dst\$) # 간선을 통해 거리 업데이트\n            for j in \$arr\$: # 음수 사이클 존재 여부 확인을 위해 한 번 더 반복\n                if \$visited[j.st]\$ == INF: # 출발지가 아직 방문되지 않았다면 무시\n                    \$continue\$\n                if \$visited[j.ed]\$ > \$visited[j.st] + j.dst\$: # 음수 사이클이 존재하면\n                    print(\"Yes\") # \"Yes\" 출력하고 함수 종료\n                    return\n    print(\"No\") # 음수 사이클이 존재하지 않으면 \"No\" 출력\n\nN, M = map(int, input().split()) # 노드 수 N과 간선 수 M 입력\nvisited = [INF] * (N + 1) # 방문 여부와 최단거리를 저장할 배열 초기화\narr = [] # 간선 정보 저장할 리스트\nfor _ in range(M): # 간선 정보 입력\n    a, b, c = map(int, input().split())\n    arr.append(Edge(a, b, c)) # Edge 클래스로 간선 생성하여 배열에 추가\nBellmanFord() # 벨만-포드 알고리즘 수행",
        "import heapq\n\nclass Edge:\n    def __init__(self, x, y, dst): # Edge 클래스 정의 (간선의 출발지, 도착지, 가중치를 저장)\n        self.x = x\n        self.y = y\n        self.dst = dst\n    def __lt__(self, other): # 비교 연산자 정의 (간선의 가중치 비교)\n        return self.dst < other.dst\n\ndef Find(x):\n    if x == arr[x]: # 루트 노드인 경우\n        return x # 자기 자신 반환\n    arr[x] = Find(arr[x]) # 경로 압축을 통해 루트 노드를 찾음\n    return arr[x]\n\ndef Union(x, y):\n    arr[Find(x)] = Find(y) # x의 루트를 y의 루트로 설정\n\ndef Kruskal():\n    ret = 0\n    while pq: # 우선순위 큐가 비어있지 않은 동안\n        top = heapq.heappop(pq) # 우선순위 큐에서 최소 가중치 간선 추출\n        x, y, curr = top.x, top.y, top.dst # 출발지, 도착지, 현재 가중치 저장\n        if Find(x) == Find(y): # 사이클이 생성되는지 확인 (두 노드의 루트가 같으면)\n            continue # 스킵\n        Union(x, y) # 두 노드를 연결\n        ret += curr # 가중치 누적\n    return ret\n\nN, M = map(int, input().split()) # 노드 수 N과 간선 수 M 입력\narr = [i for i in range(N + 1)] # 각 노드의 루트 노드 초기화\npq = [] # 우선순위 큐 초기화\n\nfor _ in range(M):\n    a, b, c = map(int, input().split()) # 출발지, 도착지, 가중치 입력\n    heapq.heappush(pq, Edge(a, b, c)) # Edge 클래스로 우선순위 큐에 추가\n\nprint(Kruskal()) # 최소 신장 트리의 가중치 합 출력",
        "import heapq\n\nclass Edge:\n    def __init__(self, x, y, dst): # Edge 클래스 정의 (간선의 출발지, 도착지, 가중치를 저장)\n        self.x = x\n        self.y = y\n        self.dst = dst\n    def __lt__(self, other): # 비교 연산자 정의 (간선의 가중치 비교)\n        return self.dst < other.dst\n\ndef Find(x):\n    if \$x\$ == arr[x]: # 루트 노드인 경우\n        return \$x\$ # 자기 자신 반환\n    arr[x] = \$Find(arr[x])\$ # 경로 압축을 통해 루트 노드를 찾음\n    return \$arr[x]\$\n\ndef Union(x, y):\n    arr[Find(x)] = \$Find(y)\$ # x의 루트를 y의 루트로 설정\n\ndef Kruskal():\n    ret = 0\n    while \$pq\$: # 우선순위 큐가 비어있지 않은 동안\n        top = \$heapq.heappop(pq)\$ # 우선순위 큐에서 최소 가중치 간선 추출\n        x, y, curr = top.x, top.y, top.dst # 출발지, 도착지, 현재 가중치 저장\n        if \$Find(x)\$ == Find(y): # 사이클이 생성되는지 확인 (두 노드의 루트가 같으면)\n            \$continue\$ # 스킵\n        Union(x, y) # 두 노드를 연결\n        \$ret\$ += \$curr\$ # 가중치 누적\n    return \$ret\$\n\nN, M = map(int, input().split()) # 노드 수 N과 간선 수 M 입력\narr = [i for i in range(N + 1)] # 각 노드의 루트 노드 초기화\npq = [] # 우선순위 큐 초기화\n\nfor _ in range(M):\n    a, b, c = map(int, input().split()) # 출발지, 도착지, 가중치 입력\n    heapq.heappush(pq, Edge(a, b, c)) # Edge 클래스로 우선순위 큐에 추가\n\nprint(Kruskal()) # 최소 신장 트리의 가중치 합 출력",
        "Just like the input and output above, understand the code below, wrap it in \$, and print it out. The part wrapped in \$ will be blank and will be presented as a question. However, the following conditions must be observed.\n\n1. The structure variable, the generator part, should never be wrapped in \$.\n2. You can't just wrap the constant in \$. \n3. The commentary should never be changed.\n4. Any part that declares a variable, such as 'ret = 0' or 'pq = []', should never be wrapped in \$. This is the same in the statement for.\n5. The part that defines a function, such as 'def Find(x):' should never be wrapped in \$.\n6. For comparative operators such as '>, '<', '==', and '!=', only the latter part of the operator should be wrapped in \$. For example, for 'a == b', only 'a == \$b\$.\n7. Parts that are entered or printed, such as 'input()' and 'print()', should not be wrapped in \$.\n8. When calling a function, if there are 0 to 2 factors of the  function, like 'a.top()', 'a.\$top()\$' wraps the entire function in \$.\n9. When calling a function, if there are three or more factors of the function, such as 'f(a, b, c), wrap the name and factor of the function with \$, as in '\$f\$(a\$, \$b\$, \$c\$).\n10. If break, continue, and return are also key parts, please wrap them in \$.\n\nWrap as much as you can in \$ to satisfy all of the above conditions and explain one by one why you wrapped those parts in \$.\nWrap the entire code in ``` without the language of that code. "
    )

    private val javaBlankPrompt = arrayListOf(
        "You read the code, identify the important parts, and drill through the blanks so that the user can match the contents that will be in the blanks.",
        "import java.util.*;\n\nclass Edge {\n    int st, ed, dst;  // 간선의 출발지, 도착지, 가중치 변수\n    Edge(int st, int ed, int dst) {  // Edge 생성자\n        this.st = st;\n        this.ed = ed;\n        this.dst = dst;\n    }\n}\n\npublic class BellmanFord {\n    \n    static final int INF = 1000000007;  // 무한대 값\n    static int N, M;  // 노드 수 N, 간선 수 M\n    static int[] visited = new int[1005];  // 방문 여부 배열\n    static ArrayList<Edge> arr = new ArrayList<>();  // 간선 정보를 담는 배열\n\n    public static void BellmanFord() {\n        for (int i = 1; i <= N; i++) {  // 모든 노드에 대하여\n            if (visited[i] == INF) {  // INF로 초기화되어 있는 경우\n                visited[i] = 0;  // 출발 노드로 설정\n                for (int j = 0; j < N; j++) {  // 모든 노드에 대하여\n                    for (int k = 0; k < arr.size(); k++) {  // 모든 간선에 대하여\n                        if (visited[arr.get(k).st] == INF)  \n                            continue;  // 출발 노드가 INF이면 다음으로 넘어감\n                        visited[arr.get(k).ed] = Math.min(visited[arr.get(k).ed], visited[arr.get(k).st] + arr.get(k).dst);  // 간선을 통해 최단 거리 갱신\n                    }\n                }\n                for (int j = 0; j < arr.size(); j++) {  // 모든 간선에 대하여\n                    if (visited[arr.get(j).st] == INF)\n                        continue;  // 출발 노드가 INF이면 다음으로 넘어감\n                    if (visited[arr.get(j).ed] > visited[arr.get(j).st] + arr.get(j).dst) {  // 음수 사이클 존재하는 경우\n                        System.out.println(\"Yes\");  // 출력하고\n                        return;  // 함수 종료\n                    }\n                }\n            }\n        }\n        System.out.println(\"No\");  // 음수 사이클이 존재하지 않는 경우\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);  // 입력을 받기 위한 스캐너 객체 생성\n        N = sc.nextInt();  // 노드 수 입력\n        M = sc.nextInt();  // 간선 수 입력\n        Arrays.fill(visited, INF);  // visited 배열을 INF로 초기화\n        for (int i = 0; i < M; i++) {  // 모든 간선 정보를 입력받음\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            arr.add(new Edge(a, b, c));  // Edge 객체를 생성하여 ArrayList에 저장\n        }\n        BellmanFord();  // Bellman-Ford 알고리즘 호출\n        sc.close();  // 스캐너 닫기\n    }\n}",
        "import java.util.*;\n\nclass Edge {\n    int st, ed, dst;  // 간선의 출발지, 도착지, 가중치 변수\n    Edge(int st, int ed, int dst) {  // Edge 생성자\n        this.st = st;\n        this.ed = ed;\n        this.dst = dst;\n    }\n}\n\npublic class BellmanFord {\n    \n    static final int INF = 1000000007;  // 무한대 값\n    static int N, M;  // 노드 수 N, 간선 수 M\n    static int[] visited = new int[1005];  // 방문 여부 배열\n    static ArrayList<Edge> arr = new ArrayList<>();  // 간선 정보를 담는 배열\n\n    public static void BellmanFord() {\n        for (int i = 1; i <= N; i++) {  // 모든 노드에 대하여\n            if (\$visited[i]\$ == INF) {  // INF로 초기화되어 있는 경우\n                visited[i] = 0;  // 출발 노드로 설정\n                for (int j = 0; j < N; j++) {  // 모든 노드에 대하여\n                    for (int k = 0; k < \$arr.size()\$; k++) {  // 모든 간선에 대하여\n                        if (\$visited[arr.get(k).st]\$ == INF)  \n                            \$continue\$;  // 출발 노드가 INF이면 다음으로 넘어감\n                        visited[arr.get(k).ed] = Math.min(\$visited[arr.get(k).ed]\$, \$visited[arr.get(k).st] + arr.get(k).dst\$);  // 간선을 통해 최단 거리 갱신\n                    }\n                }\n                for (int j = 0; j < \$arr.size()\$; j++) {  // 모든 간선에 대하여\n                    if (\$visited[arr.get(j).st]\$ == INF)\n                        \$continue\$;  // 출발 노드가 INF이면 다음으로 넘어감\n                    if (\$visited[arr.get(j).ed]\$ > \$visited[arr.get(j).st] + arr.get(j).dst\$) {  // 음수 사이클 존재하는 경우\n                        System.out.println(\"Yes\");  // 출력하고\n                        return;  // 함수 종료\n                    }\n                }\n            }\n        }\n        System.out.println(\"No\");  // 음수 사이클이 존재하지 않는 경우\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);  // 입력을 받기 위한 스캐너 객체 생성\n        N = sc.nextInt();  // 노드 수 입력\n        M = sc.nextInt();  // 간선 수 입력\n        Arrays.fill(visited, INF);  // visited 배열을 INF로 초기화\n        for (int i = 0; i < M; i++) {  // 모든 간선 정보를 입력받음\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            arr.add(new Edge(a, b, c));  // Edge 객체를 생성하여 ArrayList에 저장\n        }\n        BellmanFord();  // Bellman-Ford 알고리즘 호출\n        sc.close();  // 스캐너 닫기\n    }\n}",
        "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int x, y, dst;\n\n    Edge(int x, int y, int dst) {\n        this.x = x;\n        this.y = y;\n        this.dst = dst;\n    }\n\n    @Override\n    public int compareTo(Edge other) {\n        return Long.compare(this.dst, other.dst);  // 간선의 가중치를 기준으로 오름차순 정렬\n    }\n}\n\npublic class MST {\n    static int N, M;\n    static int[] arr = new int[1005];  // 각 정점의 부모를 저장하는 배열\n    static PriorityQueue<Edge> pq = new PriorityQueue<>();  // 간선을 저장하는 우선순위 큐\n\n    static int Find(int x) {   // 최상위 부모를 찾는 함수\n        if (x == arr[x])\n            return x;\n        return arr[x] = Find(arr[x]);  // 경로 압축을 통해 최상위 부모를 찾음\n    }\n\n    static void Union(int x, int y) {  // 두 정점을 연결하는 함수\n        arr[Find(x)] = Find(y);  // x의 부모를 y의 부모로 설정\n    }\n\n    static int Kruskal() {  // 크루스칼 알고리즘\n        int ret = 0;  // MST의 총 가중치\n        while (!pq.isEmpty()) {\n            Edge edge = pq.poll();  // 가장 작은 가중치를 가진 간선 선택\n            int x = edge.x, y = edge.y, curr = edge.dst;\n            if (Find(x) == Find(y))  // 사이클이 생기지 않는다면\n                continue;\n            Union(x, y);  // 두 정점을 연결\n            ret += curr;  // 가중치를 더함\n        }\n        return ret;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        N = sc.nextInt();  // 정점의 수\n        M = sc.nextInt();  // 간선의 수\n        for (int i = 0; i <= N; i++)\n            arr[i] = i;  // 초기에는 자기 자신을 부모로 설정\n        for (int i = 0; i < M; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            pq.add(new Edge(a, b, c));  // 인접한 정점들과 가중치를 갖는 간선을 우선순위 큐에 추가\n        }\n        System.out.println(Kruskal());  // MST의 총 가중치를 출력\n        sc.close();\n    }\n}",
        "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int x, y, dst;\n\n    Edge(int x, int y, int dst) {\n        this.x = x;\n        this.y = y;\n        this.dst = dst;\n    }\n\n    @Override\n    public int compareTo(Edge other) {\n        return Long.compare(this.dst, other.dst);  // 간선의 가중치를 기준으로 오름차순 정렬\n    }\n}\n\npublic class MST {\n    static int N, M;\n    static int[] arr = new int[1005];  // 각 정점의 부모를 저장하는 배열\n    static PriorityQueue<Edge> pq = new PriorityQueue<>();  // 간선을 저장하는 우선순위 큐\n\n    static int Find(int x) {   // 최상위 부모를 찾는 함수\n        if (\$x\$ == arr[x])\n            return \$x\$;\n        return arr[x] = \$Find(arr[x])\$;  // 경로 압축을 통해 최상위 부모를 찾음\n    }\n\n    static void Union(int x, int y) {  // 두 정점을 연결하는 함수\n        arr[Find(x)] = \$Find(y)\$;  // x의 부모를 y의 부모로 설정\n    }\n\n    static int Kruskal() {  // 크루스칼 알고리즘\n        int ret = 0;  // MST의 총 가중치\n        while (\$!pq.isEmpty()\$) {\n            Edge edge = \$pq.poll()\$;  // 가장 작은 가중치를 가진 간선 선택\n            int x = edge.x, y = edge.y, curr = edge.dst;\n            if (\$Find(x)\$ == Find(y))  // 사이클이 생기지 않는다면\n                continue;\n            Union(x, y);  // 두 정점을 연결\n            \$ret\$ += \$curr\$;  // 가중치를 더함\n        }\n        return \$ret\$;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        N = sc.nextInt();  // 정점의 수\n        M = sc.nextInt();  // 간선의 수\n        for (int i = 0; i <= N; i++)\n            arr[i] = i;  // 초기에는 자기 자신을 부모로 설정\n        for (int i = 0; i < M; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            pq.add(new Edge(a, b, c));  // 인접한 정점들과 가중치를 갖는 간선을 우선순위 큐에 추가\n        }\n        System.out.println(Kruskal());  // MST의 총 가중치를 출력\n        sc.close();\n    }\n}",
        "Just like the input and output above, understand the code below, wrap it in \$, and print it out. The part wrapped in \$ will be blank and will be presented as a question. However, the following conditions must be observed.\n\n1. The structure variable, the generator part, should never be wrapped in \$.\n2. You can't just wrap the constant in \$. \n3. The commentary should never be changed.\n4. Any part that declares a variable, such as 'int ret = 0;' or 'PriorityQueue<Edge> pq = new PriorityQueue<>();', should never be wrapped in \$. This is the same in the statement for.\n5. The part that defines a function, such as 'static int Find(int x) {' should never be wrapped in \$.\n6. For comparative operators such as '>, '<', '==', and '!=', only the latter part of the operator should be wrapped in \$. For example, for 'a == b', only 'a == \$b\$.\n7. Parts that are entered or printed, such as 'scanner.nextInt();' and 'System.out.println();', should not be wrapped in \$.\n8. When calling a function, if there are 0 to 2 factors of the  function, like 'a.top()', 'a.\$top()\$' wraps the entire function in \$.\n9. When calling a function, if there are three or more factors of the function, such as 'f(a, b, c), wrap the name and factor of the function with \$, as in '\$f\$(a\$, \$b\$, \$c\$).\n10. If break, continue, and return are also key parts, please wrap them in \$.\n\nWrap as much as you can in \$ to satisfy all of the above conditions and explain one by one why you wrapped those parts in \$.\nWrap the entire code in ``` without the language of that code. "
    )

    fun organizeAndAnnotate(code: String, language: Language): String {
        val headers = HttpHeaders()
        headers.set("Authorization", "Bearer $token")

        val annotatePrompt = when(language) {
            Language.C -> cAnnotatePrompt
            Language.PYTHON -> pythonAnnotatePrompt
            Language.JAVA -> javaAnnotatePrompt
        }

        val messageList = listOf(
            ChatMessageDto(
                role = "user",
                content = annotatePrompt[0]
            ),
            ChatMessageDto(
                role = "assistant",
                content = annotatePrompt[1]
            ),
            ChatMessageDto(
                role = "user",
                content = annotatePrompt[2]
            ),
            ChatMessageDto(
                role = "assistant",
                content = annotatePrompt[3]
            ),
            ChatMessageDto(
                role = "user",
                content = annotatePrompt[4]
            ),
            ChatMessageDto(
                role = "user",
                content = code
            )
        )

        val entity = HttpEntity(
            ChatRequestDto(
                model = "gpt-3.5-turbo",
                messages = messageList,
                temperature = 1.0,
                maxTokens = 2048
            ),
            headers
        )

        val response = restTemplate.exchange(url, HttpMethod.POST, entity, ChatResponseDto::class.java)

        return response.body!!.choices[0].message.content
    }

    fun generateBlanks(code: String, language: Language): String {
        val headers = HttpHeaders()
        headers.set("Authorization", "Bearer $token")

        val blankPrompt = when(language) {
            Language.C -> cBlankPrompt
            Language.PYTHON -> pythonBlankPrompt
            Language.JAVA -> javaBlankPrompt
        }

        val messageList = listOf(
            ChatMessageDto(
                role = "system",
                content = blankPrompt[0]
            ),
            ChatMessageDto(
                role = "user",
                content = blankPrompt[1]
            ),
            ChatMessageDto(
                role = "assistant",
                content = blankPrompt[2]
            ),
            ChatMessageDto(
                role = "user",
                content = blankPrompt[3]
            ),
            ChatMessageDto(
                role = "assistant",
                content = blankPrompt[4]
            ),
            ChatMessageDto(
                role = "user",
                content = blankPrompt[5]
            ),
            ChatMessageDto(
                role = "user",
                content = code
            )
        )

        val entity = HttpEntity(
            ChatRequestDto(
                model = "gpt-4",
                messages = messageList,
                temperature = 1.0,
                maxTokens = 2048
            ),
            headers
        )

        val response = restTemplate.exchange(url, HttpMethod.POST, entity, ChatResponseDto::class.java)

        return response.body!!.choices[0].message.content.split("```\n")[1]
    }

}